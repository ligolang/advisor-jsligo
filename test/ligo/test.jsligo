#import "../../src/advisor/main.jsligo" "ADVISOR"
#import "../../src/indice/main.jsligo" "INDICE"

const test = do {
  // constants
  const indice_initial_storage : int = 4;
  const indice_contract_path = "../../src/indice/main.jsligo"; 

  // deploy Increment INDICE contract 
  Test.log("deploy Increment INDICE smart contract");
  let res = Test.originate_from_file (indice_contract_path,indice_initial_storage, 0 as mutez);
  const inc_indice_address = res.addr;

  // INDICE Increment(1)
  Test.log("call Increment entrypoint of INDICE smart contract");
  const _a = Test.transfer_exn(inc_indice_address, (Increment(1) as parameter_of INDICE), (0 as mutez));
  const inc_actual_storage = Test.get_storage(inc_indice_address);
  Test.log(inc_actual_storage);
  assert(inc_actual_storage == indice_initial_storage + 1);

  // deploy Decrement INDICE contract 
  Test.log("deploy Decrement INDICE smart contract");
  res = Test.originate_from_file (indice_contract_path,indice_initial_storage, 0 as mutez);
  const dec_indice_address = res.addr;

  // INDICE Decrement(2)
  Test.log("call Decrement entrypoint of INDICE smart contract");
  const _b = Test.transfer_exn(dec_indice_address, (Decrement(2) as parameter_of INDICE), (0 as mutez));
  const dec_actual_storage = Test.get_storage(dec_indice_address);
  Test.log(dec_actual_storage);
  assert(dec_actual_storage == indice_initial_storage - 2);

  // deploy ADVISOR contract 
  Test.log("deploy ADVISOR smart contract");
  const advisor_initial_storage : ADVISOR.storage = {
    indiceAddress:(Test.to_address(inc_indice_address)), 
    algorithm:((i : int) => { if (i < 10) { return true } else { return false } }), 
    result: false,
    metadata: (Big_map.empty as big_map<string, bytes>)
  };
  const advisor_contract_path = "../../src/advisor/main.jsligo"; //"views_hangzhou/jsligo/advisor.jsligo";
  let advisor_res = Test.originate_from_file (advisor_contract_path,advisor_initial_storage, (0 as mutez));
  const advisor_address = advisor_res.addr;

  // ADVISOR call ExecuteAlgorithm
  Test.log("call ExecuteAlgorithm entrypoint of ADVISOR smart contract");
  {
    let _s = Test.transfer_exn(advisor_address, ((ExecuteAlgorithm(unit)) as parameter_of ADVISOR), (0 as mutez));
    const advisor_modified_storage = Test.get_storage(advisor_address);
    Test.log(advisor_modified_storage);
    assert(advisor_modified_storage.result == true);
  };

  // ADVISOR call ChangeAlgorithm
  Test.log("call ChangeAlgorithm entrypoint of ADVISOR smart contract");
  {
    const new_algo  = (i : int) : bool => { if (i < 3) { return true } else { return false } };
    let _s = Test.transfer_exn(advisor_address, ((ChangeAlgorithm(new_algo)) as parameter_of ADVISOR), (0 as mutez));
    const _advisor_modified_storage2 = Test.get_storage(advisor_address);
  };

  // ADVISOR call ExecuteAlgorithm
  Test.log("call ExecuteAlgorithm entrypoint of ADVISOR smart contract");
  {
    let _s = Test.transfer_exn(advisor_address, ((ExecuteAlgorithm(unit)) as parameter_of ADVISOR), (0 as mutez));
    const advisor_modified_storage3 = Test.get_storage(advisor_address);
    Test.log(advisor_modified_storage3);
    assert(advisor_modified_storage3.result == false);
  };
};